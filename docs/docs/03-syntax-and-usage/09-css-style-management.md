# CSS style management

## Constant attributes

templ supports standard class attributes for HTML elements.

```templ
templ button(text string) {
	<button class="button is-primary">{ text }</button>
}
```

```html title="Output"
<button class="button is-primary">
 Click me
</button>
```

## Dynamic classes

CSS libraries like https://bulma.io and https://tailwindcss.com often require lots of CSS classes to be added to an element, some of which may be optional based on data.

To support dynamic allocation of classes, the `class` attribute accepts a variadic slice of inputs:

* String constants, which are sanitized prior to rendering.
* `templ.SafeCSS` expressions which are not sanitized.
* A map of string class names to a boolean that determines if the class is added to the element (a `map[string]bool`).
* A templ CSS expression.

This allows for dynamic addition of content.

```templ title="component.templ"
package main

templ button(text string, isPrimary bool) {
	<button class={ "button", templ.KV("is-primary", isPrimary) }>{ text }</button>
}
```

```go title="main.go"
package main

import (
	"context"
	"os"
)

func main() {
	button("Click me", false).Render(context.Background(), os.Stdout)
}
```

```html title="Output"
<button class="button">
 Click me
</button>
```

## CSS elements

You can use a standard `<style>` element within a template and its contents will be rendered to the output without any changes.

```templ
templ page() {
	<style type="text/css">
		p {
			font-family: sans-serif;
		}
		.button {
			background-color: black;
			foreground-color: white;
		}
	</style>
	<p>
		Paragraph contents.
	</p>
}
```

```html title="Output"
<style type="text/css">
	p {
		font-family: sans-serif;
	}
	.button {
		background-color: black;
		foreground-color: white;
	}
</style>
<p>
	Paragraph contents.
</p>
```

:::tip
If you want to make sure that the CSS element is only output once, even if you use a template many times, use a CSS expression.
:::


## CSS expressions

When developing a component library, it may not be desirable to require that specific CSS classes are present when the HTML is rendered.

There may be CSS class name clashes, or developers may forget to include the required CSS.

To support inclusion of CSS within a component library, templ supports CSS components.

```templ title="component.templ"
package main

var red = "#ff0000";

css className() {
	background-color: #ffffff;
	color: { red };
}

templ button(text string) {
	<button class={ className, "button" }>{ text }</button>
}
```

```html title="Output"
<style type="text/css">
 .className_f179{background-color:#ffffff;color:#ff0000;}
</style>
<button class="className_f179 button">
 Click me
</button>
```

:::info
The CSS class is given a unique name the first time it is used, and only rendered once per HTTP request to save bandwidth.
:::

:::caution
The class name is autogenerated, don't rely on it being consistent.
:::

### CSS Middleware

The use of CSS templates means that `<style>` elements containing the CSS are rendered on each HTTP request.

To save bandwidth, templ can provide a global stylesheet that includes the output of CSS templates instead of including `<style>` tags in each HTTP request.

To provide a global stylesheet, use templ's CSS middleware, and register templ classes on application startup.

The middleware adds a HTTP route to the web server (`/styles/templ.css` by default) that renders the `text/css` classes that would otherwise be added to `<style>` tags when components are rendered. 

For example, to stop the `className` CSS class from being added to the output, the HTTP middleware can be used.

```go
c1 := className()
handler := NewCSSMiddleware(httpRoutes, c1)
http.ListenAndServe(":8000:, handler)
```

:::caution
Don't forget to add a `<link rel="stylesheet" href="/styles/templ.css">` to your HTML to include the generated CSS class names!
:::
